# =============================================================================
# RusingAcademy Ecosystem â€” Production Deployment Pipeline
# Sprint Y1-W1-S01 | Chief Ecosystem Orchestrator
# =============================================================================
# Manual trigger only (workflow_dispatch). Requires the "production" environment
# approval gate to be configured in GitHub repository settings.
# This workflow is a placeholder for when a separate production Railway service
# is created. Currently, the single Railway service serves as both staging
# and production (auto-deploys from main).
# =============================================================================

name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm_deploy:
        description: "Type 'DEPLOY' to confirm production deployment"
        required: true
        type: string
      commit_sha:
        description: "Commit SHA to deploy (must match staging-validated commit)"
        required: true
        type: string

concurrency:
  group: deploy-production
  cancel-in-progress: false

permissions:
  contents: read
  deployments: write

env:
  PRODUCTION_URL: "https://new-rusingacademy-project-production.up.railway.app"

jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Validate deployment request
  # ---------------------------------------------------------------------------
  validate:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    steps:
      - name: Verify confirmation
        run: |
          if [ "${{ github.event.inputs.confirm_deploy }}" != "DEPLOY" ]; then
            echo "::error::Deployment not confirmed. You must type 'DEPLOY' to proceed."
            exit 1
          fi
          echo "Deployment confirmed"

      - name: Verify commit SHA
        run: |
          echo "Requested commit: ${{ github.event.inputs.commit_sha }}"
          echo "Current HEAD: ${{ github.sha }}"
          echo "Commit SHA recorded for audit trail"

  # ---------------------------------------------------------------------------
  # Job 2: Deploy to production (requires environment approval)
  # ---------------------------------------------------------------------------
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: validate
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.commit_sha }}

      - name: Record deployment
        run: |
          echo "=== Production Deployment Record ==="
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Commit: ${{ github.event.inputs.commit_sha }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "Workflow run: ${{ github.run_id }}"
          echo ""
          echo "Note: Railway auto-deploys from main. This workflow serves as"
          echo "an audit trail and approval gate. When a separate production"
          echo "Railway service is created, this workflow will trigger the"
          echo "actual deployment via Railway API."

  # ---------------------------------------------------------------------------
  # Job 3: Post-deploy health check
  # ---------------------------------------------------------------------------
  verify:
    name: Production Health Check
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Wait for deployment propagation
        run: sleep 30

      - name: Health check - Homepage
        run: |
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 30 "${{ env.PRODUCTION_URL }}/")
          echo "Homepage: HTTP $HTTP_STATUS"
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "::error::Production health check FAILED"
            exit 1
          fi
          echo "Production is healthy"

      - name: Health check - Critical routes
        run: |
          ROUTES="/login /courses /pricing /about /api/health"
          FAILED=0
          for ROUTE in $ROUTES; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -L --max-time 15 "${{ env.PRODUCTION_URL }}${ROUTE}")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "PASS ${ROUTE}: HTTP $HTTP_STATUS"
            else
              echo "FAIL ${ROUTE}: HTTP $HTTP_STATUS"
              FAILED=$((FAILED + 1))
            fi
          done
          if [ "$FAILED" -gt 0 ]; then
            echo "::error::$FAILED critical route(s) failed in production"
            exit 1
          fi
          echo ""
          echo "=== Production Deployment Verified ==="
          echo "All critical routes responding HTTP 200"
          echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
